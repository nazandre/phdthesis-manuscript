\section{Summary}

In this work, we considered systems composed of resource-constrained modules that are organized in a lattice structure and which can only communicate with neighboring modules. We identified and implemented three high-level primitives, namely centrality-based leader election, time synchronization and self-reconfiguration.

We proposed a collection of efficient and effective distributed algorithms to elect approximate-centroid and approximate-center nodes in asynchronous distributed systems. We introduced the $k$-BFS SumSweep framework, the ABC-Center algorithm and the Probabilistic-Counter-based Central-Leader Election (PC2LE) framework. Our algorithms and frameworks do not require any prior knowledge of the network, have a well-defined termination criterion, converge in a reasonable amount of time and are memory-efficient. The $k$-BFS SumSweep framework runs in $O(kd)$ time using $O(mn^2)$ messages of size $O(1)$ and $O(\Delta)$ memory space per node. We proposed two versions of ABC-Center. The latest version, ABC-CenterV2, runs in $O(sd)$ time using $O(mn^2)$ messages of size $O(1)$ and $O(\Delta)$ memory space per node, where $s$ is the number of iterations ABC-CenterV2 requires to terminate. PC2LE runs in $O(d)$ time using $O(mn^2)$ messages of size $O(c)$ and $O(\Delta + c)$ memory space per node, where $c$ is the memory usage of the probabilistic counter used in PC2LE. If we consider that the maximum number of neighbors a node can have is bounded by a constant, the memory usage of our algorithms is further reduced to $O(1)$, for $k$-BFS SumSweep and ABC-CenterV2, and to $O(c)$ for PC2LE. It is, for instance, the case in many modular robotic systems that use neighbor-to-neighbor communications (e.g, the Blinky Blocks, the Smart Blocks, etc.). We evaluated the proposed algorithms on the Blinky Blocks modular robotic system both on hardware prototypes and through simulations. Our algorithms scale well in terms of accuracy, execution time, number of messages and memory usage. In large-scale systems with 25,000 modules, our algorithms provide a relative centroid accuracy between 96\%-99\% and a relative center accuracy between 88\%-94\%. As a consequence, our algorithms are suitable for large-scale embedded distributed systems with scarce memory, computing and energy resources. To the best of our knowledge, our algorithms are the most precise existing distributed algorithms designed to elect an approximate centroid or an approximate center in our target systems, with both a reasonable convergence time and a limited storage cost.

Furthermore, we introduced the Modular Robot Time Protocol (MRTP), a network-wide time synchronization protocol for modular robots. Our protocol achieves its performance by combining several mechanisms: central time master election, fast and recursive propagation of synchronization waves along the edges of a breadth-first spanning tree, low-level timestamping with per-hop compensation for communication delays using the most-appropriate method for the target platform, and clock skew compensation using linear regression. We evaluated our protocol on the Blinky Blocks system both on hardware and through simulations. Experimental results show that MRTP can potentially manage real systems composed of up to 27,775 Blinky Blocks. Furthermore, we showed that our protocol is able to keep a Blinky Blocks system synchronized to a few milliseconds, using few network resources at runtime, even though the Blinky Blocks use low-bitrate communications (38.4 kbit/s) and are equipped with very low-accuracy (10,000 parts per million (ppm)) and poor-resolution (1 millisecond) clocks. We compared MRTP to existing synchronization protocols ported to fit our system model. Simulation results show that MRTP can achieve better synchronization precision than the most precise protocols compared, while sending more than half less messages in compact systems.

Additionally, we presented the Cylindrical-Catoms Self-Reconfiguration (C2SR) algorithm, a self-reconfiguration algorithm for rolling cylindrical modules arranged in a two-dimensional vertical hexagonal lattice. Our algorithm is a parallel, asynchronous and decentralized distributed algorithm allowing the self-reconfiguration of robots from an initial configuration into a goal one. It is able to manage almost any kind of initial and goal compact shapes (i.e., without any hole). We showed the effectiveness of our algorithm and studied its performance in terms of communications, movements and execution time using simulations. Our observations indicate that the number of communications, the number of movements and the execution time of our algorithm are highly predictable. Furthermore, we observed execution times that are linear in the size of the goal shape.

\section{Future Work}

This section presents perspectives on future research. We first discuss improvements to our three primitives and then suggest more general future work.

\paragraph{Centrality-based Leader Election}

In future work, it will be interesting to carry out a formal analysis of the accuracy of our algorithms in order to derive bounds or to try to find bad cases, where our algorithms fail. For now, we did not faced any really bad case during our experiments.

PC2LE estimates $d$, the diameter of the network, to bound the number of rounds. With the method proposed in this chapter, the estimation is upper-bounded by $2d$. Thus, in the worst case, PC2LE unnecessarily performs $d$ rounds, which uses $O(d)$ time and generates $O(dm)$ messages for nothing. In future work, it will be interesting to find an efficient method to better estimate $d$.

Furthermore, our work on network centrality can potentially be applied to a wide variety of distributed systems. In future work, we plan to evaluate the performance of our algorithms on different systems and, if necessary, to propose system-specific adaptations. 

The number of iterations required for ABC-Center to terminate increases with the diameter thickness. Intuitively, the number of iterations tends to increase with the network density, as the number of equidistant nodes between any two nodes tends to be greater in dense networks. While ABC-Center requires only a few iterations in modular robotic systems where nodes are organized in a simple-cubic lattice, its efficiency has to be studied in other types of networks.

In addition, we plan to study the problems of centrality-based leader election in networks that exhibit a high degree of dynamics due to nodes failure and/or mobility. Currently, our algorithms restart computations from scratch upon neighbor change detection. This mechanism will be too expensive in terms of resource usage in highly dynamic networks.

We also plan to extend the controlled-broadcast optimization, proposed in Section~\ref{section:centrality-controlled-broadcast}, into a framework that will make it possible to run multiple \gls{bfs} traversals (including election traversals) in parallel, without network congestion. In the envisaged framework, we will ensure that at most $O(1)$ \gls{bfs} messages for all \gls{bfs} traversals will be present in any outgoing-message queue at all times. We would like to use this framework to design a more efficient version of the $k$-BFS-RAND-PAR algorithm (see Section~\ref{section:centrality:compared-algorithms}).

\paragraph{Time Synchronization}
We plan to test MRTP in large-scale hardware systems running real applications, which have time synchronization requirements and which may potentially generate a significant network and computing load.

In addition, it would be interesting to design more precise methods of compensating for network delays in Blinky Blocks systems. We envision, for instance, to enhance FD with a method that will compensate for the dissemination error after several hops, i.e., when this error has become greater than the resolution of the clock and can effectively be compensated for. Also, different network delay compensation methods can be combined to provide a better estimation of the current global time. In order not to increase the communication load, a same message can carry multiple timestamps inserted by different methods.

In future versions of MRTP, we want to consider both centrality and clock stability in the time-master election. We also want to adapt MRTP to deal with outlier slave modules equipped with less stable clocks than the others.

Furthermore, MRTP should be tested in other modular robotic systems that fit its system model. In particular, it will be interesting to determine if the predictive method to compensate for communication delays is still more precise than the other methods in systems with higher hardware-clock accuracy.

Moreover, we plan to study time synchronization in highly dynamic modular robotic systems where module mobility and failures may occur frequently. In particular, we want to address the problem of time synchronization throughout the process of self-reconfiguration, during which modules move to rearrange the global shape of the modular robot (e.g.,~\cite{pb16:ip},\cite{lakhlef2014optimization}). MRTP needs to be adapted to efficiently handle such network dynamics, because the frequent re-elections of a central module and the maintenance of the synchronization tree will be too expensive. For now, we suggest using the high-level framework of the PulseSync protocol~\cite{lenzen2015pulsesync} in those systems. This framework is indeed inherently tolerant of module mobility and failures.

%Moreover, we plan to study time synchronization in highly dynamic modular robotic systems where module mobility and failures may occur frequently.
%In this work, we test our algorithms on ensembles composed of less than a hundred of hardware robots. In future work, we envision to deploy our algorithms in larger-scale hardware systems running real applications on top of our primitives.

\paragraph{Self-Reconfiguration} In future work, we will demonstrate the correctness of C2SR, i.e., we will prove that the goal configuration can be built if the shape admissibility conditions are satisfied. Moreover, we will study the performance of C2SR on other types of shapes and compare it to existing algorithms. We will also study the distribution of both the number of messages sent per module and the number of atomic moves performed per module. Our observations seem to indicate that our algorithm is highly predictable and that its execution time is linear with respect to the size of the goal shape. A further step would be to prove it. 

In the design of C2SR, we tried to prevent modules from unnecessarily climbing over others, assuming that going up may consume more energy. C2SR fulfills this goal when modules travel on the periphery of the initial shape, which is progressively stripped so that no module can go up. However, if the goal shape contains hills on its periphery, hills close to the initial shape will be completely constructed before modules can continue to roll on the periphery of the goal shape. Hence, many modules will then have to climb up these hills to reach the other side of the goal shape. We would like to overcome this limitation in the future version of C2SR. Peripheral modules that have already converged can, for instance, advertise remote modules in the stream about farther goal cells to be filled, thus, causing modules in the stream not to freeze in a hill.

Modules of modular robotic ensembles are low-cost mass-produced tiny electronic devices that are inherently prone to failures. Failures should then be considered when designing primitives for these ensembles. In particular, we do not consider module failures in our self-reconfiguration algorithm and it would be interesting to adapt our algorithm so that it can cope with such failures.

In addition, it will be interesting to extend our algorithm so that it will be able to cope with 3D modular robotic systems such as the 3D Catoms~\cite{piranda2016geom} which can roll over neighboring modules in the 3D space. It could be done by constructing the goal shape plane by plane, every plane being constructed line by line, as in the current version of C2SR. However, in ensembles of 3D Catoms, several paths may exist to reach a given cell, thus, faster approaches which allow many modules to move concurrently can be envisioned.

\paragraph{Set of Primitives}

Other primitives have to be identified and studied in future work. Some challenging algorithmic problems in large-scale robotic ensembles have already been studied for years, e.g., robot localization~\cite{funiak-ijrr08, moffo2016first}, reconfiguration goal shape compression~\cite{tucci2017efficient}, locomotion~\cite{fitch2007scalable}, coating~\cite{derakhshandeh2017algorithmic}, reconfiguration termination detection~\cite{butler_distributed_2002}. In my opinion, other interesting primitives include data dissemination, data sharing, message routing and construction of a virtual representation of robot ensembles. 

In chapter~\ref{chapter:context}, we explain how \acrfull{pm} could be used to enhance the computer-aided design process because \gls{pm} provides a consistent mapping between the virtual and physical representations of a same object. Hardware modules have limited memory capacity and may not afford to store the complete reconfiguration goal shape even in a compressed format. Data dissemination algorithms, data sharing protocols combined with appropriate routing methods will, for instance, enable to disseminate and share large virtual representations between all modules. In this approach, every module does not store the complete virtual representation of an object but instead, only a part of it and can transparently access locally and remotely stored parts of the goal representation. This will reduce the individual memory usage of modules during the reconfiguration process.

The construction of a virtual representation of robot ensembles would enable designers to update their virtual representation of an object after having manually modified its physical representation made of \gls{pm}. The virtual representation could possibly be reconstructed using external means (e.g., cameras and imagery processing) or by the modules themselves using communications.

Furthermore, it will be interesting to release primitive implementations in a set of libraries in order to provide a complete software environment for large-scale distributed modular robotic ensemble coordination.

%Similarly as in the Buzz programming language~\cite{pinciroli2016buzz}, libraries could even be incorporated in a programming language as high-level functionalities.